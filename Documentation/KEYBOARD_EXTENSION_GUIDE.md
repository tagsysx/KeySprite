# é”®ç›˜æ‰©å±•å¼€å‘æŒ‡å—

## ğŸ“± æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†å¦‚ä½•åœ¨KeySpriteé¡¹ç›®ä¸­å¼€å‘iOSè‡ªå®šä¹‰é”®ç›˜æ‰©å±•ï¼ŒåŒ…æ‹¬é…ç½®ã€å®ç°å’Œæœ€ä½³å®è·µã€‚

## ğŸ¯ å¼€å‘ç›®æ ‡

- åˆ›å»ºåŠŸèƒ½å®Œæ•´çš„iOSè‡ªå®šä¹‰é”®ç›˜æ‰©å±•
- å®ç°å¤šç§é”®ç›˜å¸ƒå±€ï¼ˆè‹±æ–‡ã€ä¸­æ–‡ã€æ•°å­—ã€ç¬¦å·ã€Emojiï¼‰
- é›†æˆAIæ™ºèƒ½å¸ƒå±€æ¨èåŠŸèƒ½
- æä¾›ä¼˜ç§€çš„ç”¨æˆ·ä½“éªŒå’Œæ€§èƒ½è¡¨ç°

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### 1. é”®ç›˜æ‰©å±•æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    iOS System                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Input Method Kit  â”‚  Text Input Mode  â”‚  Keyboard UI      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                KeySprite Keyboard Extension                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  KeyboardViewController  â”‚  Layout Manager  â”‚  Input Engine  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  QWERTY  â”‚  Chinese  â”‚  Number  â”‚  Symbol  â”‚  Emoji      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ ¸å¿ƒç»„ä»¶

- **KeyboardViewController**: é”®ç›˜æ‰©å±•çš„ä¸»æ§åˆ¶å™¨
- **LayoutManager**: é”®ç›˜å¸ƒå±€ç®¡ç†å™¨
- **InputEngine**: è¾“å…¥å¤„ç†å¼•æ“
- **AIPredictor**: AIé¢„æµ‹æœåŠ¡

## ğŸ”§ é…ç½®æ­¥éª¤

### æ­¥éª¤1: åˆ›å»ºé”®ç›˜æ‰©å±•Target

1. åœ¨Xcodeä¸­é€‰æ‹©File > New > Target
2. é€‰æ‹©iOS > Application Extension > Custom Keyboard Extension
3. è®¾ç½®äº§å“åç§°ï¼šKeySpriteKeyboard
4. é€‰æ‹©è¯­è¨€ï¼šSwift
5. ç¡®ä¿åŒ…å«åœ¨ä¸»é¡¹ç›®ä¸­

### æ­¥éª¤2: é…ç½®Info.plist

```xml
<!-- KeySpriteKeyboard/Info.plist -->
<key>NSExtension</key>
<dict>
    <key>NSExtensionAttributes</key>
    <dict>
        <key>IsASCIICapable</key>
        <true/>
        <key>PrefersRightToLeft</key>
        <false/>
        <key>PrimaryLanguage</key>
        <string>en-US</string>
        <key>RequestsOpenAccess</key>
        <true/>
    </dict>
    <key>NSExtensionMainStoryboard</key>
    <string>MainInterface</string>
    <key>NSExtensionPointIdentifier</key>
    <string>com.apple.keyboard-service</string>
</dict>
```

## ğŸš€ æ ¸å¿ƒå®ç°

### 1. KeyboardViewController

```swift
import UIKit
import InputMethodKit

class KeyboardViewController: UIInputViewController {
    
    // MARK: - Properties
    private var layoutManager: KeyboardLayoutManager!
    private var aiPredictor: AIPredictor!
    private var inputEngine: InputEngine!
    
    // MARK: - UI Components
    private var keyboardView: KeyboardView!
    private var candidateView: CandidateView?
    private var layoutIndicator: LayoutIndicatorView!
    
    // MARK: - State
    private var currentLayout: KeyboardLayout = .qwerty
    private var isShifted: Bool = false
    private var isCapsLocked: Bool = false
    
    // MARK: - Lifecycle
    override func viewDidLoad() {
        super.viewDidLoad()
        setupComponents()
        setupConstraints()
        setupGestures()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        updateKeyboardLayout()
        updateAIRecommendation()
    }
    
    // MARK: - Setup
    private func setupComponents() {
        // åˆå§‹åŒ–å¸ƒå±€ç®¡ç†å™¨
        layoutManager = KeyboardLayoutManager()
        
        // åˆå§‹åŒ–AIé¢„æµ‹å™¨
        aiPredictor = AIPredictor()
        
        // åˆå§‹åŒ–è¾“å…¥å¼•æ“
        inputEngine = InputEngine()
        
        // åˆ›å»ºé”®ç›˜è§†å›¾
        keyboardView = KeyboardView()
        view.addSubview(keyboardView)
        
        // åˆ›å»ºå€™é€‰è¯è§†å›¾
        candidateView = CandidateView()
        view.addSubview(candidateView!)
        
        // åˆ›å»ºå¸ƒå±€æŒ‡ç¤ºå™¨
        layoutIndicator = LayoutIndicatorView()
        view.addSubview(layoutIndicator)
    }
    
    // MARK: - Layout Management
    private func updateKeyboardLayout() {
        let layout = layoutManager.getCurrentLayout()
        keyboardView.updateLayout(layout)
        layoutIndicator.updateLayout(layout)
        
        // æ›´æ–°AIæ¨è
        updateAIRecommendation()
    }
    
    private func switchToLayout(_ layout: KeyboardLayout) {
        layoutManager.switchToLayout(layout)
        updateKeyboardLayout()
        
        // è®°å½•ç”¨æˆ·é€‰æ‹©
        UserDefaults.standard.set(layout.rawValue, forKey: "LastSelectedLayout")
    }
    
    // MARK: - AI Integration
    private func updateAIRecommendation() {
        let currentInput = getCurrentInput()
        let context = getCurrentContext()
        
        aiPredictor.predictNextLayout(input: currentInput, context: context) { [weak self] result in
            DispatchQueue.main.async {
                self?.handleAIRecommendation(result)
            }
        }
    }
    
    private func handleAIRecommendation(_ result: Result<LayoutRecommendation, Error>) {
        switch result {
        case .success(let recommendation):
            if recommendation.confidence > 0.7 {
                showLayoutRecommendation(recommendation)
            }
        case .failure(let error):
            print("AIæ¨èå¤±è´¥: \(error)")
        }
    }
    
    // MARK: - Input Handling
    private func handleKeyPress(_ key: KeyboardKey) {
        switch key.type {
        case .character:
            insertText(key.displayText)
            updateAIRecommendation()
            
        case .backspace:
            deleteBackward()
            
        case .space:
            insertText(" ")
            updateAIRecommendation()
            
        case .return:
            insertText("\n")
            
        case .shift:
            toggleShift()
            
        case .layout:
            switchToLayout(key.associatedLayout)
            
        case .emoji:
            showEmojiPicker()
        }
    }
    
    // MARK: - Text Input
    private func insertText(_ text: String) {
        textDocumentProxy.insertText(text)
        
        // æ›´æ–°å€™é€‰è¯
        if currentLayout == .chinese {
            updateCandidateWords()
        }
    }
    
    private func deleteBackward() {
        textDocumentProxy.deleteBackward()
        
        // æ›´æ–°å€™é€‰è¯
        if currentLayout == .chinese {
            updateCandidateWords()
        }
    }
    
    // MARK: - Helper Methods
    private func getCurrentInput() -> String {
        return textDocumentProxy.documentContextBeforeInput ?? ""
    }
    
    private func getCurrentContext() -> InputContext {
        return InputContext(
            textBeforeCursor: textDocumentProxy.documentContextBeforeInput ?? "",
            textAfterCursor: textDocumentProxy.documentContextAfterInput ?? "",
            currentWord: getCurrentWord(),
            appType: .other,
            inputFieldType: .text,
            timeOfDay: getCurrentTimeOfDay(),
            userActivity: .typing
        )
    }
    
    private func getCurrentWord() -> String {
        let beforeInput = textDocumentProxy.documentContextBeforeInput ?? ""
        let words = beforeInput.components(separatedBy: .whitespacesAndNewlines)
        return words.last ?? ""
    }
    
    private func getCurrentTimeOfDay() -> TimeOfDay {
        let hour = Calendar.current.component(.hour, from: Date())
        switch hour {
        case 6..<12: return .morning
        case 12..<18: return .afternoon
        case 18..<22: return .evening
        default: return .night
        }
    }
}
```

### 2. é”®ç›˜å¸ƒå±€ç®¡ç†å™¨

```swift
import Foundation

class KeyboardLayoutManager {
    
    // MARK: - Properties
    private var currentLayout: KeyboardLayout = .qwerty
    private var availableLayouts: [KeyboardLayout] = [.qwerty, .chinese, .number, .symbol, .emoji]
    private var layoutHistory: [KeyboardLayout] = []
    private var layoutPreferences: [KeyboardLayout: Float] = [:]
    
    // MARK: - Initialization
    init() {
        loadLayoutPreferences()
        loadLastUsedLayout()
    }
    
    // MARK: - Public Methods
    func getCurrentLayout() -> KeyboardLayout {
        return currentLayout
    }
    
    func switchToLayout(_ layout: KeyboardLayout) {
        guard availableLayouts.contains(layout) else { return }
        
        // ä¿å­˜å½“å‰å¸ƒå±€åˆ°å†å²
        saveLayoutToHistory(currentLayout)
        
        // æ›´æ–°å½“å‰å¸ƒå±€
        currentLayout = layout
        
        // æ›´æ–°ä½¿ç”¨åå¥½
        updateLayoutPreference(layout)
        
        // ä¿å­˜è®¾ç½®
        saveLayoutPreferences()
    }
    
    func getRecommendedLayout() -> KeyboardLayout {
        // åŸºäºç”¨æˆ·åå¥½å’Œä½¿ç”¨å†å²æ¨èå¸ƒå±€
        let recommendations = calculateLayoutRecommendations()
        return recommendations.first ?? .qwerty
    }
    
    func getPreviousLayout() -> KeyboardLayout? {
        return layoutHistory.last
    }
    
    func getAvailableLayouts() -> [KeyboardLayout] {
        return availableLayouts
    }
    
    // MARK: - Private Methods
    private func saveLayoutToHistory(_ layout: KeyboardLayout) {
        layoutHistory.append(layout)
        
        // é™åˆ¶å†å²è®°å½•æ•°é‡
        if layoutHistory.count > 10 {
            layoutHistory.removeFirst()
        }
    }
    
    private func updateLayoutPreference(_ layout: KeyboardLayout) {
        let currentPreference = layoutPreferences[layout] ?? 0.0
        layoutPreferences[layout] = currentPreference + 1.0
    }
    
    private func calculateLayoutRecommendations() -> [KeyboardLayout] {
        // åŸºäºåå¥½åˆ†æ•°æ’åºå¸ƒå±€
        let sortedLayouts = availableLayouts.sorted { layout1, layout2 in
            let score1 = layoutPreferences[layout1] ?? 0.0
            let score2 = layoutPreferences[layout2] ?? 0.0
            return score1 > score2
        }
        
        return sortedLayouts
    }
    
    private func loadLayoutPreferences() {
        let userDefaults = UserDefaults.standard
        
        for layout in availableLayouts {
            let key = "LayoutPreference_\(layout.rawValue)"
            let preference = userDefaults.float(forKey: key)
            layoutPreferences[layout] = preference
        }
    }
    
    private func saveLayoutPreferences() {
        let userDefaults = UserDefaults.standard
        
        for (layout, preference) in layoutPreferences {
            let key = "LayoutPreference_\(layout.rawValue)"
            userDefaults.set(preference, forKey: key)
        }
        
        userDefaults.synchronize()
    }
    
    private func loadLastUsedLayout() {
        let userDefaults = UserDefaults.standard
        if let layoutString = userDefaults.string(forKey: "LastUsedLayout"),
           let layout = KeyboardLayout(rawValue: layoutString) {
            currentLayout = layout
        }
    }
}

// MARK: - KeyboardLayout Enum
enum KeyboardLayout: String, CaseIterable {
    case qwerty = "QWERTY"
    case chinese = "Chinese"
    case number = "Number"
    case symbol = "Symbol"
    case emoji = "Emoji"
    
    var displayName: String {
        switch self {
        case .qwerty: return "è‹±æ–‡"
        case .chinese: return "ä¸­æ–‡"
        case .number: return "æ•°å­—"
        case .symbol: return "ç¬¦å·"
        case .emoji: return "è¡¨æƒ…"
        }
    }
    
    var iconName: String {
        switch self {
        case .qwerty: return "keyboard"
        case .chinese: return "character"
        case .number: return "number"
        case .symbol: return "textformat"
        case .emoji: return "face.smiling"
        }
    }
}
```

## ğŸ¨ UIç»„ä»¶å®ç°

### 1. é”®ç›˜è§†å›¾

```swift
import UIKit

class KeyboardView: UIView {
    
    // MARK: - Properties
    private var currentLayout: KeyboardLayout = .qwerty
    private var keys: [[KeyboardKey]] = []
    private var keyViews: [[UIButton]] = []
    private var keyPreviewView: KeyPreviewView?
    
    // MARK: - Initialization
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupView()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        setupView()
    }
    
    // MARK: - Setup
    private func setupView() {
        backgroundColor = UIColor.systemBackground
        layer.cornerRadius = 8
        layer.masksToBounds = true
        
        setupKeys()
        setupKeyViews()
    }
    
    private func setupKeys() {
        keys = currentLayout.getKeys()
    }
    
    private func setupKeyViews() {
        // æ¸…é™¤ç°æœ‰æŒ‰é”®è§†å›¾
        keyViews.forEach { row in
            row.forEach { $0.removeFromSuperview() }
        }
        keyViews.removeAll()
        
        // åˆ›å»ºæ–°çš„æŒ‰é”®è§†å›¾
        for (rowIndex, row) in keys.enumerated() {
            var keyRow: [UIButton] = []
            
            for (colIndex, key) in row.enumerated() {
                let keyButton = createKeyButton(for: key)
                keyButton.tag = rowIndex * 100 + colIndex
                addSubview(keyButton)
                keyRow.append(keyButton)
            }
            
            keyViews.append(keyRow)
        }
        
        updateKeyConstraints()
    }
    
    private func createKeyButton(for key: KeyboardKey) -> UIButton {
        let button = UIButton(type: .system)
        button.setTitle(key.displayText, for: .normal)
        button.titleLabel?.font = UIFont.systemFont(ofSize: 18, weight: .medium)
        button.backgroundColor = key.backgroundColor
        button.setTitleColor(key.textColor, for: .normal)
        button.layer.cornerRadius = 6
        button.layer.masksToBounds = true
        
        // æ·»åŠ è§¦æ‘¸äº‹ä»¶
        button.addTarget(self, action: #selector(keyTapped(_:)), for: .touchUpInside)
        
        return button
    }
    
    // MARK: - Public Methods
    func updateLayout(_ layout: KeyboardLayout) {
        currentLayout = layout
        setupKeys()
        setupKeyViews()
    }
    
    func updateShiftState(isShifted: Bool, isCapsLocked: Bool) {
        // æ›´æ–°Shifté”®çŠ¶æ€
        for row in keyViews {
            for keyButton in row {
                if let key = getKeyForButton(keyButton), key.type == .shift {
                    updateShiftKeyAppearance(keyButton, isShifted: isShifted, isCapsLocked: isCapsLocked)
                }
            }
        }
    }
    
    // MARK: - Private Methods
    private func getKeyForButton(_ button: UIButton) -> KeyboardKey? {
        let tag = button.tag
        let rowIndex = tag / 100
        let colIndex = tag % 100
        
        guard rowIndex < keys.count && colIndex < keys[rowIndex].count else {
            return nil
        }
        
        return keys[rowIndex][colIndex]
    }
    
    // MARK: - Actions
    @objc private func keyTapped(_ sender: UIButton) {
        let tag = sender.tag
        let rowIndex = tag / 100
        let colIndex = tag % 100
        
        guard rowIndex < keys.count && colIndex < keys[rowIndex].count else {
            return
        }
        
        let key = keys[rowIndex][colIndex]
        
        // å‘é€æŒ‰é”®äº‹ä»¶
        NotificationCenter.default.post(
            name: .keyTapped,
            object: key
        )
    }
}

// MARK: - Notification Names
extension Notification.Name {
    static let keyTapped = Notification.Name("keyTapped")
}
```

## ğŸ§ª æµ‹è¯•å’Œè°ƒè¯•

### 1. å•å…ƒæµ‹è¯•

```swift
import XCTest
@testable import KeySpriteKeyboard

class KeyboardViewControllerTests: XCTestCase {
    
    var keyboardViewController: KeyboardViewController!
    
    override func setUp() {
        super.setUp()
        keyboardViewController = KeyboardViewController()
    }
    
    override func tearDown() {
        keyboardViewController = nil
        super.tearDown()
    }
    
    func testInitialization() {
        XCTAssertNotNil(keyboardViewController)
        XCTAssertNotNil(keyboardViewController.view)
    }
    
    func testLayoutSwitching() {
        // æµ‹è¯•å¸ƒå±€åˆ‡æ¢
        let initialLayout = keyboardViewController.layoutManager.getCurrentLayout()
        keyboardViewController.switchToLayout(.chinese)
        let newLayout = keyboardViewController.layoutManager.getCurrentLayout()
        
        XCTAssertEqual(newLayout, .chinese)
        XCTAssertNotEqual(initialLayout, newLayout)
    }
}
```

## ğŸš¨ å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

### 1. é”®ç›˜ä¸æ˜¾ç¤º

**é—®é¢˜**: é”®ç›˜æ‰©å±•æ— æ³•æ˜¾ç¤º
**è§£å†³æ–¹æ¡ˆ**:
- æ£€æŸ¥Info.plisté…ç½®
- éªŒè¯Bundle Identifierè®¾ç½®
- ç¡®ä¿é”®ç›˜æ‰©å±•å·²å¯ç”¨
- æ£€æŸ¥å¼€å‘è¯ä¹¦é…ç½®

### 2. æŒ‰é”®æ— å“åº”

**é—®é¢˜**: æŒ‰é”®ç‚¹å‡»æ— ååº”
**è§£å†³æ–¹æ¡ˆ**:
- æ£€æŸ¥äº‹ä»¶ç»‘å®š
- éªŒè¯çº¦æŸè®¾ç½®
- ç¡®ä¿è§†å›¾å±‚çº§æ­£ç¡®
- æ£€æŸ¥è§¦æ‘¸äº‹ä»¶å¤„ç†

## ğŸ“š å‚è€ƒèµ„æ–™

- [Custom Keyboard Extension](https://developer.apple.com/documentation/inputmethodkit)
- [iOS Input Method Development](https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Keyboard.html)
- [Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines)

## ğŸ“ æ›´æ–°æ—¥å¿—

| ç‰ˆæœ¬ | æ—¥æœŸ | æ›´æ–°å†…å®¹ |
|------|------|----------|
| 1.0.0 | 2024-01-XX | åˆå§‹é”®ç›˜æ‰©å±•å¼€å‘æŒ‡å— |

---

**æ³¨æ„**: æœ¬æŒ‡å—æä¾›äº†é”®ç›˜æ‰©å±•å¼€å‘çš„åŸºç¡€æ¡†æ¶ï¼Œå®é™…å®ç°æ—¶éœ€è¦æ ¹æ®å…·ä½“éœ€æ±‚è¿›è¡Œè°ƒæ•´å’Œä¼˜åŒ–ã€‚
